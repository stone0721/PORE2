#include <iostream>
#include <string>
#include <vector>
#include <stdint.h>
#include <sstream>
#include <unistd.h> // for usleep
#include <cstdio>   // for putchar, fflush
#include <cstring>  // for strlen
#include <cstdint>  // for uint32_t

std::vector<std::string> map1{
    "*#############################\n",
    "*********#####################\n",
    "########***************#*****#\n",
    "########*#############*#*#####\n",
    "#********#############*#*###*#\n",
    "###*##################***#####\n",
    "###*#########**********#*###*#\n",
    "###*#################*##*#####\n",
    "#***#################**#*###*#\n",
    "##*##################*##*#####\n",
    "##**#################**#***#*#\n",
    "###*#################*########\n",
    "##**#####**###***##*#**#####*#\n",
    "##*###################*#######\n",
    "##**#################**#####*#\n",
    "###**********##*******########\n",
    "############*#**#####****###*#\n",
    "#######################*######\n",
    "#####################***####*#\n",
    "#####################*########\n",
    "#****#######****#####***####*#\n",
    "#######################*######\n",
    "###################*#***####*#\n",
    "#####################*########\n",
    "#######**********####***####*#\n",
    "#######################*######\n",
    "#####################***####*#\n",
    "#####################*########\n",
    "#*****************###***####*#\n",
    "######################*#######\n",
    "#*###################**#####*#\n",
    "#####################*########\n",
    "#*#**#********#######****###*#\n",
    "#####################*########\n",
    "#*##*#*######*****###*######*#\n",
    "#####################*########\n",
    "#*##*#*##############******#*#\n",
    "######****************########\n",
    "#**#*#*#####################*#\n",
    "######*#######################\n",
    "####*#***********************#\n",
    "####***#######################\n",
    "#****#########################\n",
    "####**########################\n",
    "#*###*********************####\n",
    "#*****########################\n",
    "#*############################\n",
    "#*############################\n",
    "#*#####################******#\n",
    "#*############################\n",
    "#*****************############\n",
    "#*############################\n",
    "#*############################\n",
    "#*############################\n",
    "#***#***#***######**##########\n",
    "###*##########################\n",
    "#*#**######*******************\n",
    "####*#########################\n",
    "#**#*##*#**###*#####*#########\n",
    "####*#########################\n",
    "#*##*###*#########**####*#####\n",
    "####*#########################\n",
    "#*##**##****#############*####\n",
    "#####****#####################\n",
    "##############################\n"};

std::vector<std::string> map2{
    "##############################",
    "##############################",
    "*###***#***######*######**####",
    "##############################",
    "*####***#########***##########",
    "##############################",
    "***##***#**##*###*############",
    "##############################",
    "*##*#**####*******************",
    "##############################",
    "***#****#**######***##########",
    "##############################",
    "*#############################",
    "##############################",
    "******************##*#########",
    "##############################",
    "*###*###############*##*****##",
    "##############################",
    "*###*###############*#########",
    "##############################",
    "*###**********************####",
    "##############################",
    "****##########################",
    "##############################",
    "*#####**********************##",
    "##############################",
    "***###########################",
    "##############################",
    "*####################******###",
    "##############################",
    "*############*****########*###",
    "##############################",
    "*##*##*******#########***#*###",
    "##############################",
    "*#######################*#*###",
    "##############################",
    "******************######*#*###",
    "##############################",
    "*#######################*#*###",
    "##############################",
    "*##*##***********#######*#*###",
    "##############################",
    "*##*##*###########*#####*#*###",
    "##############################",
    "****##*####*****##*#####*#*###",
    "##############################",
    "**####*####*######*#####*#*###",
    "##############################",
    "**####*####**#**##*####**#*###",
    "##############################",
    "**####*#####*#####*#######*###",
    "##############################",
    "*#####*##**#*#***#**######*###",
    "##############################",
    "*#####*#####*###########***###",
    "##############################",
    "**####*#####*#################",
    "##############################",
    "######*#####*********#########",
    "##############################",
    "********######################",
    "##############################",
    "*#######**************##****##",
    "##############################",
    "*#############################"};

std::vector<std::string> map3{
    "##############################",
    "##############################",
    "########**************##****##",
    "##############################",
    "********#*####################",
    "##############################",
    "#########*##*********#########",
    "##############################",
    "**#######*####################",
    "##############################",
    "#########*##############**####",
    "##############################",
    "########***##****#*###########",
    "##############################",
    "#**##########*##*#############",
    "##############################",
    "##*########*#****######*######",
    "##############################",
    "##*############**#############",
    "##############################",
    "****#######******#############",
    "##############################",
    "################*#*###########",
    "##############################",
    "######***********#############",
    "##############################",
    "##############################",
    "##############################",
    "#*****************############",
    "##############################",
    "#################*############",
    "##############################",
    "##**##*******####*####**######",
    "##############################",
    "##*##########*****############",
    "##############################",
    "##*##################*****####",
    "##############################",
    "#**###########################",
    "##############################",
    "######**********************##",
    "##############################",
    "#***##########################",
    "##############################",
    "####**********************####",
    "##############################",
    "##############################",
    "##############################",
    "######################******##",
    "##############################",
    "#****************#####*#######",
    "##############################",
    "######################*##*####",
    "##############################",
    "#**#*******#*#*##***#####*####",
    "##############################",
    "###*###**##*******************",
    "##############################",
    "#**###*#**###############*####",
    "##############################",
    "#######**####*###***#####*####",
    "##############################",
    "####*###***##*##########*#####",
    "##############################",
    "##############################"};

bool valid(int x, int y)
{
    bool result = false;
    // 根据y的值执行不同分支
    switch (y % 3)
    {
    case 0:
        result = (map1[x][y / 3] == '*');
        break;
    case 1:
        // 检查map2中(64-x)位置的字符
        result = (map2[64 - x][y / 3] == '*');
        break;
    case 2:
        result = (map3[x][y / 3] == '*');
        break;
    }
    if (!result)
    {
        std::cout << "error: " << "x: " << x << "  y: " << y << std::endl;
    }
    return result;
}

// 当达到目标时调用

void processString(const std::string& input) {
    //local_238[0] currentCount
    //local_238[1]
    //local_238[2]  i=1 -> input.size()
    //local_238[3]
    // 定义字符映射表
    const std::string charMap = "AflporeBCDgPOREFGHaIJKLMNQSTUVW{XYZbcdhijk1mnqs2}3t4u5v6w7x8y9z0";
    
    // 输出初始信息
    std::cout << std::endl;
    std::cout << charMap[8] << charMap[4] << charMap[0x2c]; 
              //   C             o                  n
    if (input.empty()) return;
    char currentChar = input[0];
    std::cout << charMap[10] << charMap[5] << charMap[0x12]; // 输出其他信息
               //   g            r                   a
    std::vector<uint32_t> countVector;
    uint32_t currentCount = 1;
    std::cout << charMap[0x32] << charMap[0x34] << charMap[0x2]; // 输出更多信息
                      //   t             u              l
    // 统计连续字符
    for (size_t i = 1; i < input.size(); i++) {
        if (input[i] == currentChar) {
            currentCount++;
        } else {
            countVector.push_back(currentCount);
            currentCount = 1;
            currentChar = input[i];
        }
    }
    std::cout << charMap[0x12] << charMap[0x32] << charMap[0x27]; // 输出"o!"
              //     a              t                  i
    countVector.push_back(0x30);
    std::cout << charMap[4] << charMap[0x2c] << "!\n";
                //   o             n
    
    // 处理统计结果并输出
    std::stringstream ss;
    for (uint32_t count : countVector) {
        uint32_t index = count & 0x3f;
        /*
        if (static_cast<int32_t>(count) < 1) {
            index = -(-count & 0x3f);
        }
        */
        ss << charMap[index];
    }
    
    std::cout << ss.str() << std::endl;
}

void start(const std::string &str)
{ // 参数未使用到
    int x = 0, y = 0;
    std::string path;   // 记录有效路径
    std::string output; // 输出字符串
    char input;
    while (std::cin >> input)
    {
        bool moved = false;
        // 处理移动指令
        if (input == 'w' && x > 1 && valid(x - 2, y))
        {
            x -= 2;
            path += 'w';
            moved = true;
        }
        else if (input == 's' && x < 0x3f && valid(x + 2, y))
        {
            x += 2;
            path += 's';
            moved = true;
        }
        else if (input == 'a' && y > -1 && valid(x, y - 1))
        {
            y -= 1;
            path += 'a';
            moved = true;
        }
        else if (input == 'd' && y < 0x5a && valid(x, y + 1))
        {
            y += 1;
            path += 'd';
            moved = true;
        }
        // 添加输入到输出
        if (!moved)
        {
            output += input;
        }
        // 特殊条件处理
        size_t len = output.size();
        if (len % 5 == 1)
        {
            output += "nice";
            continue; // 不检查是否达到目标
        }
        else if (len % 5 == 2)
        {
            output += "yes";
        }
        // 检查是否达到目标
        if (x == 0x38 && y == 0x59 && path.size() < 0x20a)
        {
            processString(path);
            return;
        }
        if (len % 5 == 4)
        {
            output += "!";
        }
        std::cout << " x: " << x << "  y: " << y << std::endl;
    }
}

int main()
{
    // 创建并处理字符串
    std::string input = "11111";
    start(input);
    return 0;
}